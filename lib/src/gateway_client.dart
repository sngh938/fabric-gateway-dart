// Thin wrapper around generated gRPC stubs will live here.
// This file will import generated proto stubs from `lib/src/protos/` and
// expose higher-level methods used by the SDK.

// At runtime this wrapper will hold references to the generated gRPC client
// stubs (e.g. `GatewayClient` generated by protoc) and translate between the
// higher-level SDK types and the protobuf message types.

import 'dart:async';
import 'dart:typed_data';

import 'package:grpc/grpc.dart' as $grpc;

import 'protos/gateway/gateway.pb.dart' as $gw;
import 'protos/gateway/gateway.pbgrpc.dart' as $gwgrpc;

/// GatewayClient provides low-level RPC helper methods used by the SDK.
///
/// This concrete implementation wraps the generated gRPC stub `gateway.GatewayClient`.
class GatewayClient {
  final $grpc.ClientChannel _channel;
  final $gwgrpc.GatewayClient _stub;

  /// Construct a GatewayClient from an existing gRPC channel.
  GatewayClient(this._channel) : _stub = $gwgrpc.GatewayClient(_channel);

  /// Evaluate a request using the gateway Evaluate RPC.
  Future<$gw.EvaluateResponse> evaluate($gw.EvaluateRequest request,
      {$grpc.CallOptions? options}) async {
    return await _stub.evaluate(request, options: options);
  }

  /// Endorse a prepared transaction (Endorse RPC).
  Future<$gw.EndorseResponse> endorse($gw.EndorseRequest request,
      {$grpc.CallOptions? options}) async {
    return await _stub.endorse(request, options: options);
  }

  /// Submit a signed transaction to ordering service (Submit RPC).
  Future<$gw.SubmitResponse> submit($gw.SubmitRequest request,
      {$grpc.CallOptions? options}) async {
    return await _stub.submit(request, options: options);
  }

  /// Query commit status for a transaction (CommitStatus RPC).
  Future<$gw.CommitStatusResponse> commitStatus(
      $gw.SignedCommitStatusRequest request,
      {$grpc.CallOptions? options}) async {
    return await _stub.commitStatus(request, options: options);
  }

  /// Stream chaincode events using server-streaming RPC.
  Stream<$gw.ChaincodeEventsResponse> chaincodeEvents(
      $gw.SignedChaincodeEventsRequest request,
      {$grpc.CallOptions? options}) {
    return _stub.chaincodeEvents(request, options: options);
  }

  /// Stream block/filtered/block+private data events via Deliver (if implemented).
  /// Currently the gateway uses gateway.Orderer/Deliver on the orderer side; this
  /// method is a placeholder for future Deliver usage or wrapper around other protos.
  Stream<Uint8List> blockEvents(Uint8List requestBytes) {
    // TODO: implement when deliver/streaming message wrappers are defined.
    return Stream<Uint8List>.error(
        UnimplementedError('blockEvents not implemented'));
  }

  /// Close underlying channels / stubs.
  Future<void> close() async {
    await _channel.shutdown();
  }
}
